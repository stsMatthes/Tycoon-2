class AtMutableKeyedContainer(K <: Object, E <: Object)
super AtGiveByKeyMixin(K,E)
(*
 * This file is part of the Tycoon-2 system.
 *
 * The Tycoon-2 system is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation (Version 2).
 *
 * The Tycoon-2 system is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty
 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public
 * License along with the Tycoon-2 system; see the file LICENSE.
 * If not, write to AB 4.02, Softwaresysteme, TU Hamburg-Harburg
 * D-21071 Hamburg, Germany. (http://www.sts.tu-harburg.de)
 * 
 * Copyright (c) 1996-1998 Higher-Order GmbH, Hamburg. All rights reserved.
 *

Mutable Keyed Container of Components
Mostly copy & paste from MutableKeyedContainer

Author:  Axel Wienberg
Date:    25-Jun-1998
*)
meta AbstractClass
{

"[]:="(k :K, e @: E) :Void
  (* Insert component e at key k. Set free old component. *)
  require validKey(k)
  ensure self[k] == old e 
  deferred

"[]@"(k :K) :E
  (* Take out the component stored at key k
     The key remains, and the value assigned to <k> becomes nil@.
     Other elements stay at their old key positions. *)
  require includesKey(k)
  ensure result == old self[k] && self[k].isNil && size = old size
deferred

validKey(k:K) :Bool
  (* May <k> be used as a key for assignment ?
     If includesKey(k), assignment is always allowed.
     The set of possible further keys may depend on class, object and current state. *)
{ ;; default: all non-nil objects
  k.isNotNil
}

memoize(k :K, ifAbsent :Fun()@:E) :E
  (* memoize the result of calling <ifAbsent> for <k>.
    <ifAbsent> is called iff  !includesKey(k) || { self[k].isNil }
    If called, <ifAbsent> must return a non-nil component value, which is
    stored under key <k>. 
    returns a reference to the updated self[k] *)
  require validKey(k)
  ensure includesKey(k) & self[k].isNotNil
{
  lookup(k, fun(e:E) {
    if( e.isNil then: {
      c @::= ifAbsent[]@
      r ::= c  ;; save a reference to the component
      self[k] := c@
      r
    } else: { e })
  }, {
    c @::= ifAbsent[]@
    r ::= c  ;; save a reference to the component
    self[k] := c@
    r
  })
}

swap(k1 :K, k2 :K) :Void
  (* Exchange elements with keys k1 and k2 *)
require includesKey(k1) & includesKey(k2)
ensure self[k1] == old self[k2]
    && self[k2] == old self[k1]
{
  assert({ includesKey(k1) & includesKey(k2) })
  
  temp @::= self[k1]@
  self[k1] := self[k2]@
  self[k2] := temp@
}

private

}
