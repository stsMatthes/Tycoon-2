(*
 * This file is part of the Tycoon-2 system.
 *
 * The Tycoon-2 system is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation (Version 2).
 *
 * The Tycoon-2 system is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty
 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public
 * License along with the Tycoon-2 system; see the file LICENSE.
 * If not, write to AB 4.02, Softwaresysteme, TU Hamburg-Harburg
 * D-21071 Hamburg, Germany. (http://www.sts.tu-harburg.de)
 * 
 * Copyright (c) 1996-1998 Higher-Order GmbH, Hamburg. All rights reserved.
 *
 File: AbstractSgmlTreeBuilder.tc
 Author: Axel Wienberg
   Date: 11-Jan-1997
Purpose:
  An (abstract) SgmlTreeBuilder is an SgmlOutput that builds a tree.  The kind
  of tree produced depends on the specific subclass of SgmlTreeBuilder.
Usage:
  Create an SgmlTreeBuilder, e.g. <tb>, use is as SgmlOutput for a call to
  SgmlsParser::parse, and fetch the produced tree from tb.tree. Before a new
  run, call tb.reset.
*)

class AbstractSgmlTreeBuilder(T <: Object)
super SgmlOutput
metaclass AbstractClass
public

interestedInPosition :Bool,
interestedInComments :Bool,
path :String,
lineNumber :Int,

tree :T

methods

reset
{
  composers.clear,
  elements.clear,
  addApplicationElements,
  tree := nil
}

(* SgmlOutput protocol *)

(* Generic identifier <id> has content type <contentType>.
   defaultAttributeValues contains an entry for each attribute with a default
   value. *)
defineElement( id :String, contentType :SgmlContentType,
		   defaultAttributeValues :Dictionary(String, String))
{ !elements.includesKey(id)
  ? { (* not registered during init *)
      addElement( defaultElement(id, contentType, defaultAttributeValues) ) }
}

startElement(gi :String, attributes :Dictionary(String, String))
{ flushBuf,
  composers.addFirst(
    SgmlComposer.new(
      elements[gi],
      position,
      attributes))
}

endElement(gi :String)
{ assert !composers.isEmpty,
  flushBuf,
  let composer = composers.removeFirst,
  assert composer.element.name = gi,
  let x =
    composer.element.build(
      let startPosition = composer.position,
      let endPosition   = position,
      composer.attributes,
      composer.components),
  !composers.isEmpty
  ? { composers[0].add(x) }
  : { tree := x }
}

comment(c :String)
{ flushBuf,
  composers[0].add(makeComment(position, c))
}

write(c :Char)
{
  interestedInPosition
  ? { dataPosition.isNil
      ? { dataPosition := position },
      c == '\n'
      ? { lineNumber := lineNumber + 1 } },
  dataBuf.write(c)
}

writeBuffer(buffer :String, start :Int, n :Int)
{
  interestedInPosition
  ? { dataPosition.isNil
      ? { dataPosition := position },
      lineNumber := lineNumber +
        buffer.subSequenceReader(start,n).occurrencesOf('\n') },
  dataBuf.writeBuffer(buffer, start, n)
}

private

elements :Dictionary(String, AbstractSgmlElement(T)),

dataBuf :StringBuilderOutput,
dataPosition :SgmlPos,

composers :Stack(SgmlComposer(T))

methods

position :SgmlPos
{ interestedInPosition
  ? { SgmlPos.new(path, lineNumber) }
  : { nil }
}

addElement(element :AbstractSgmlElement(T))
{ elements[element.name] := element }

(* call <addElement> for all application-specific non-default elements *)
addApplicationElements
{ }

(* create an SgmlElement that has no special meaning to the application.
   SgmlElements with special meaning should be registered via addElement
   in method addApplicationElements, which is called on initialization and reset. *)
defaultElement( gi :String, contentType :SgmlContentType,
	        defaultAttributes :Dictionary(String, String)) :AbstractSgmlElement(T)
  deferred

(* construct a leaf for the tree from character data *)
makeLeaf(position :SgmlPos, value :String) :T
  deferred

(* construct a comment leaf for the tree from character data *)
makeComment(position :SgmlPos, value :String) :T
  deferred

_init :Void
{ super._init,
  dataBuf := StringBuilderOutput.new,
  composers := Stack.new,
  elements := Dictionary.new,
  interestedInPosition := false,
  interestedInComments := false,
  addApplicationElements,
  self
}

flushBuf
{
  let data = dataBuf.contents,
  !data.isEmpty ? {
    composers[0].add(makeLeaf(dataPosition, data)),
    dataPosition := nil,
    dataBuf.clear
  }
}
;

